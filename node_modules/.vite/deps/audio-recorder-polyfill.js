import "./chunk-7REXU52E.js";

// node_modules/audio-recorder-polyfill/wave-encoder/index.js
var wave_encoder_default = () => {
  let BYTES_PER_SAMPLE = 2;
  let recorded = [];
  function encode(buffer) {
    let length = buffer.length;
    let data = new Uint8Array(length * BYTES_PER_SAMPLE);
    for (let i = 0; i < length; i++) {
      let index = i * BYTES_PER_SAMPLE;
      let sample = buffer[i];
      if (sample > 1) {
        sample = 1;
      } else if (sample < -1) {
        sample = -1;
      }
      sample = sample * 32768;
      data[index] = sample;
      data[index + 1] = sample >> 8;
    }
    recorded.push(data);
  }
  function dump(sampleRate) {
    let bufferLength = recorded.length ? recorded[0].length : 0;
    let length = recorded.length * bufferLength;
    let wav = new Uint8Array(44 + length);
    let view = new DataView(wav.buffer);
    view.setUint32(0, 1380533830, false);
    view.setUint32(4, 36 + length, true);
    view.setUint32(8, 1463899717, false);
    view.setUint32(12, 1718449184, false);
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * BYTES_PER_SAMPLE, true);
    view.setUint16(32, BYTES_PER_SAMPLE, true);
    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true);
    view.setUint32(36, 1684108385, false);
    view.setUint32(40, length, true);
    for (let i = 0; i < recorded.length; i++) {
      wav.set(recorded[i], i * bufferLength + 44);
    }
    recorded = [];
    postMessage(wav.buffer, [wav.buffer]);
  }
  onmessage = (e) => {
    if (e.data[0] === "encode") {
      encode(e.data[1]);
    } else if (e.data[0] === "dump") {
      dump(e.data[1]);
    }
  };
};

// node_modules/audio-recorder-polyfill/index.js
var AudioContext = window.AudioContext || window.webkitAudioContext;
var createWorker = (fn) => {
  let js = fn.toString().replace(/^(\(\)\s*=>|function\s*\(\))\s*{/, "").replace(/}$/, "");
  let blob = new Blob([js]);
  return new Worker(URL.createObjectURL(blob));
};
var error = (method) => {
  let event = new Event("error");
  event.data = new Error("Wrong state for " + method);
  return event;
};
var context;
var MediaRecorder = class _MediaRecorder {
  /**
   * @param {MediaStream} stream The audio stream to record.
   */
  constructor(stream, config = null) {
    this.stream = stream;
    this.config = config;
    this.state = "inactive";
    this.em = document.createDocumentFragment();
    this.encoder = createWorker(_MediaRecorder.encoder);
    let recorder = this;
    this.encoder.addEventListener("message", (e) => {
      let event = new Event("dataavailable");
      event.data = new Blob([e.data], { type: recorder.mimeType });
      recorder.em.dispatchEvent(event);
      if (recorder.state === "inactive") {
        recorder.em.dispatchEvent(new Event("stop"));
      }
    });
  }
  /**
   * Begins recording media.
   *
   * @param {number} [timeslice] The milliseconds to record into each `Blob`.
   *                             If this parameter isnâ€™t included, single `Blob`
   *                             will be recorded.
   *
   * @return {undefined}
   *
   * @example
   * recordButton.addEventListener('click', () => {
   *   recorder.start()
   * })
   */
  start(timeslice) {
    if (this.state !== "inactive") {
      return this.em.dispatchEvent(error("start"));
    }
    this.state = "recording";
    if (!context) {
      context = new AudioContext(this.config);
    }
    this.clone = this.stream.clone();
    this.input = context.createMediaStreamSource(this.clone);
    this.processor = context.createScriptProcessor(2048, 1, 1);
    this.encoder.postMessage(["init", context.sampleRate]);
    this.processor.onaudioprocess = (e) => {
      if (this.state === "recording") {
        this.encoder.postMessage(["encode", e.inputBuffer.getChannelData(0)]);
      }
    };
    this.input.connect(this.processor);
    this.processor.connect(context.destination);
    this.em.dispatchEvent(new Event("start"));
    if (timeslice) {
      this.slicing = setInterval(() => {
        if (this.state === "recording")
          this.requestData();
      }, timeslice);
    }
    return void 0;
  }
  /**
   * Stop media capture and raise `dataavailable` event with recorded data.
   *
   * @return {undefined}
   *
   * @example
   * finishButton.addEventListener('click', () => {
   *   recorder.stop()
   * })
   */
  stop() {
    if (this.state === "inactive") {
      return this.em.dispatchEvent(error("stop"));
    }
    this.requestData();
    this.state = "inactive";
    this.clone.getTracks().forEach((track) => {
      track.stop();
    });
    this.processor.disconnect();
    this.input.disconnect();
    return clearInterval(this.slicing);
  }
  /**
   * Pauses recording of media streams.
   *
   * @return {undefined}
   *
   * @example
   * pauseButton.addEventListener('click', () => {
   *   recorder.pause()
   * })
   */
  pause() {
    if (this.state !== "recording") {
      return this.em.dispatchEvent(error("pause"));
    }
    this.state = "paused";
    return this.em.dispatchEvent(new Event("pause"));
  }
  /**
   * Resumes media recording when it has been previously paused.
   *
   * @return {undefined}
   *
   * @example
   * resumeButton.addEventListener('click', () => {
   *   recorder.resume()
   * })
   */
  resume() {
    if (this.state !== "paused") {
      return this.em.dispatchEvent(error("resume"));
    }
    this.state = "recording";
    return this.em.dispatchEvent(new Event("resume"));
  }
  /**
   * Raise a `dataavailable` event containing the captured media.
   *
   * @return {undefined}
   *
   * @example
   * this.on('nextData', () => {
   *   recorder.requestData()
   * })
   */
  requestData() {
    if (this.state === "inactive") {
      return this.em.dispatchEvent(error("requestData"));
    }
    return this.encoder.postMessage(["dump", context.sampleRate]);
  }
  /**
   * Add listener for specified event type.
   *
   * @param {"start"|"stop"|"pause"|"resume"|"dataavailable"|"error"}
   * type Event type.
   * @param {function} listener The listener function.
   *
   * @return {undefined}
   *
   * @example
   * recorder.addEventListener('dataavailable', e => {
   *   audio.src = URL.createObjectURL(e.data)
   * })
   */
  addEventListener(...args) {
    this.em.addEventListener(...args);
  }
  /**
   * Remove event listener.
   *
   * @param {"start"|"stop"|"pause"|"resume"|"dataavailable"|"error"}
   * type Event type.
   * @param {function} listener The same function used in `addEventListener`.
   *
   * @return {undefined}
   */
  removeEventListener(...args) {
    this.em.removeEventListener(...args);
  }
  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {Event} event The event object.
   *
   * @return {boolean} Is event was no canceled by any listener.
   */
  dispatchEvent(...args) {
    this.em.dispatchEvent(...args);
  }
};
MediaRecorder.prototype.mimeType = "audio/wav";
MediaRecorder.isTypeSupported = (mimeType) => {
  return MediaRecorder.prototype.mimeType === mimeType;
};
MediaRecorder.notSupported = !navigator.mediaDevices || !AudioContext;
MediaRecorder.encoder = wave_encoder_default;
var audio_recorder_polyfill_default = MediaRecorder;
export {
  audio_recorder_polyfill_default as default
};
//# sourceMappingURL=audio-recorder-polyfill.js.map
