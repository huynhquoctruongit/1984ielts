import "./chunk-7REXU52E.js";

// node_modules/@directus/sdk/dist/chunk-GJVD322O.js
var R = { fetch: globalThis.fetch, WebSocket: globalThis.WebSocket, URL: globalThis.URL };
var w = (e, t = {}) => {
  let o = t.globals ? { ...R, ...t.globals } : R;
  return { globals: o, url: new o.URL(e), with(s) {
    return { ...this, ...s(this) };
  } };
};
function D(e) {
  return typeof e != "object" || !e ? false : "headers" in e && "ok" in e && "json" in e && typeof e.json == "function" && "text" in e && typeof e.json == "function";
}
async function g(e) {
  var _a;
  if (!(typeof e != "object" || !e)) {
    if (D(e)) {
      let t = (_a = e.headers.get("Content-Type")) == null ? void 0 : _a.toLowerCase();
      if ((t == null ? void 0 : t.startsWith("application/json")) || (t == null ? void 0 : t.startsWith("application/health+json"))) {
        let o = await e.json();
        if (!e.ok)
          throw o;
        return "data" in o ? o.data : o;
      }
      if ((t == null ? void 0 : t.startsWith("text/html")) || (t == null ? void 0 : t.startsWith("text/plain"))) {
        let o = await e.text();
        if (!e.ok)
          throw o;
        return o;
      }
      return e;
    }
    return "data" in e ? e.data : e;
  }
}
var y = async (e, t, o = globalThis.fetch) => {
  t.headers = typeof t.headers == "object" && !Array.isArray(t.headers) ? t.headers : {};
  let s = await o(e, t);
  return g(s).catch((m2) => {
    throw { errors: typeof m2 == "object" && "errors" in m2 ? m2.errors : m2, response: s };
  });
};
var I = {};
var W = (e = {}) => (t) => {
  let o = { ...I, ...e };
  return { async query(s, m2, c = "items") {
    let a = { method: "POST", body: JSON.stringify({ query: s, variables: m2 }) };
    "credentials" in o && (a.credentials = o.credentials);
    let n = {};
    if ("getToken" in this) {
      let l = await this.getToken();
      l && (n.Authorization = `Bearer ${l}`);
    }
    "Content-Type" in n || (n["Content-Type"] = "application/json"), a.headers = n;
    let d = c === "items" ? "/graphql" : "/graphql/system", f = S(t.url, d);
    return await y(f.toString(), a, t.globals.fetch);
  } };
};
var _ = (e, t, o = {}) => () => {
  let s = { email: e, password: t };
  return "otp" in o && (s.otp = o.otp), s.mode = o.mode ?? "cookie", { path: "/auth/login", method: "POST", body: JSON.stringify(s) };
};
var q = (e) => () => ({ path: "/auth/logout", method: "POST", body: JSON.stringify(e ? { refresh_token: e } : {}) });
var z = (e, t) => () => ({ path: "/auth/password/request", method: "POST", body: JSON.stringify({ email: e, ...t ? { reset_url: t } : {} }) });
var Y = (e, t) => () => ({ path: "/auth/password/reset", method: "POST", body: JSON.stringify({ token: e, password: t }) });
var ee = () => () => ({ path: "/auth", method: "GET" });
var re = (e = "cookie", t) => () => ({ path: "/auth/refresh", method: "POST", body: JSON.stringify(e === "json" ? { refresh_token: t, mode: e } : { mode: e }) });
var de = (e, t) => () => ({ path: "/activity/comment", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var ue = (e, t) => () => ({ path: "/collections", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Se = (e, t) => () => ({ path: "/dashboards", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var le = (e, t) => () => ({ path: "/dashboards", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var xe = (e, t, o) => () => ({ path: `/fields/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "POST" });
var Te = (e, t) => () => ({ path: "/files", method: "POST", body: e, params: t ?? {}, headers: { "Content-Type": "multipart/form-data" } });
var be = (e, t = {}, o) => () => ({ path: "/files/import", method: "POST", body: JSON.stringify({ url: e, data: t }), params: o ?? {} });
var Ce = (e, t) => () => ({ path: "/flows", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Re = (e, t) => () => ({ path: "/flows", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var ge = (e, t) => () => ({ path: "/folders", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Oe = (e, t) => () => ({ path: "/folders", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Ie = (e, t, o) => () => {
  let s = String(e);
  if (s.startsWith("directus_"))
    throw new Error("Cannot use createItems for core collections");
  return { path: `/items/${s}`, params: o ?? {}, body: JSON.stringify(t), method: "POST" };
};
var Fe = (e, t, o) => () => {
  let s = String(e);
  if (s.startsWith("directus_"))
    throw new Error("Cannot use createItem for core collections");
  return { path: `/items/${s}`, params: o ?? {}, body: JSON.stringify(t), method: "POST" };
};
var Ee = (e, t) => () => ({ path: "/notifications", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var we = (e, t) => () => ({ path: "/notifications", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var ve = (e, t) => () => ({ path: "/operations", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Ue = (e, t) => () => ({ path: "/operations", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var $e = (e, t) => () => ({ path: "/panels", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Ke = (e, t) => () => ({ path: "/panels", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Le = (e, t) => () => ({ path: "/permissions", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var We = (e, t) => () => ({ path: "/permissions", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Ve = (e, t) => () => ({ path: "/presets", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var He = (e, t) => () => ({ path: "/presets", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Be = (e) => () => ({ path: "/relations", body: JSON.stringify(e), method: "POST" });
var Me = (e, t) => () => ({ path: "/roles", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var ze = (e, t) => () => ({ path: "/roles", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Ye = (e, t) => () => ({ path: "/shares", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Ze = (e, t) => () => ({ path: "/shares", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var tt = (e, t) => () => ({ path: "/translations", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var rt = (e, t) => () => ({ path: "/translations", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var st = (e, t) => () => ({ path: "/users", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var mt = (e, t) => () => ({ path: "/users", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var nt = (e, t) => () => ({ path: "/versions", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var ct = (e, t) => () => ({ path: "/versions", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var pt = (e, t) => () => ({ path: "/webhooks", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var dt = (e, t) => () => ({ path: "/webhooks", params: t ?? {}, body: JSON.stringify(e), method: "POST" });
var Nt = (e) => () => ({ path: `/activity/comment/${e}`, method: "DELETE" });
var Ut = (e) => () => ({ path: `/collections/${e}`, method: "DELETE" });
var O = (e) => {
  let t = {};
  if (Array.isArray(e.fields) && e.fields.length > 0) {
    let o = (s, m2 = []) => {
      if (typeof s == "object") {
        let c = [];
        for (let a in s) {
          let n = s[a] ?? [];
          if (Array.isArray(n))
            for (let d of n)
              c.push(o(d, [...m2, a]));
          else if (typeof n == "object")
            for (let d of Object.keys(n)) {
              let f = n[d];
              for (let l of f)
                c.push(o(l, [...m2, `${a}:${d}`]));
            }
        }
        return c.flatMap((a) => a);
      }
      return [...m2, String(s)].join(".");
    };
    t.fields = e.fields.flatMap((s) => o(s)).join(",");
  }
  e.filter && Object.keys(e.filter).length > 0 && (t.filter = JSON.stringify(e.filter)), e.search && (t.search = e.search), "sort" in e && e.sort && (t.sort = typeof e.sort == "string" ? e.sort : e.sort.join(",")), typeof e.limit == "number" && e.limit >= -1 && (t.limit = String(e.limit)), typeof e.offset == "number" && e.offset >= 0 && (t.offset = String(e.offset)), typeof e.page == "number" && e.page >= 1 && (t.page = String(e.page)), e.deep && Object.keys(e.deep).length > 0 && (t.deep = JSON.stringify(e.deep)), e.alias && Object.keys(e.alias).length > 0 && (t.alias = JSON.stringify(e.alias)), e.aggregate && Object.keys(e.aggregate).length > 0 && (t.aggregate = JSON.stringify(e.aggregate)), e.groupBy && e.groupBy.length > 0 && (t.groupBy = e.groupBy.join(","));
  for (let [o, s] of Object.entries(e))
    o in t || (typeof s == "string" || typeof s == "number" || typeof s == "boolean" ? t[o] = String(s) : t[o] = JSON.stringify(s));
  return t;
};
var r = (e, t) => {
  if (e.length === 0)
    throw new Error(t);
};
var h = (e, t) => {
  if (String(e).startsWith("directus_"))
    throw new Error(t);
};
var _t = (e) => () => (r(e, "Keys cannot be empty"), { path: "/dashboards", body: JSON.stringify(e), method: "DELETE" });
var Bt = (e) => () => (r(e, "Key cannot be empty"), { path: `/dashboards/${e}`, method: "DELETE" });
var zt = (e, t) => () => (r(e, "Collection cannot be empty"), r(t, "Field cannot be empty"), { path: `/fields/${e}/${t}`, method: "DELETE" });
var Zt = (e) => () => (r(e, "Keys cannot be empty"), { path: "/files", body: JSON.stringify(e), method: "DELETE" });
var er = (e) => () => (r(e, "Key cannot be empty"), { path: `/files/${e}`, method: "DELETE" });
var or = (e) => () => (r(e, "Keys cannot be empty"), { path: "/flows", body: JSON.stringify(e), method: "DELETE" });
var sr = (e) => () => (r(e, "Key cannot be empty"), { path: `/flows/${e}`, method: "DELETE" });
var nr = (e) => () => (r(e, "Keys cannot be empty"), { path: "/folders", body: JSON.stringify(e), method: "DELETE" });
var cr = (e) => () => (r(e, "Key cannot be empty"), { path: `/folders/${e}`, method: "DELETE" });
var dr = (e, t) => () => {
  let o = {};
  return r(String(e), "Collection cannot be empty"), h(e, "Cannot use deleteItems for core collections"), Array.isArray(t) ? (r(t, "keysOrQuery cannot be empty"), o = { keys: t }) : (r(Object.keys(t), "keysOrQuery cannot be empty"), o = { query: t }), { path: `/items/${e}`, body: JSON.stringify(o), method: "DELETE" };
};
var hr = (e, t) => () => (r(String(e), "Collection cannot be empty"), h(e, "Cannot use deleteItem for core collections"), r(String(t), "Key cannot be empty"), { path: `/items/${e}/${t}`, method: "DELETE" });
var Sr = (e) => () => (r(e, "Keys cannot be empty"), { path: "/notifications", body: JSON.stringify(e), method: "DELETE" });
var lr = (e) => () => (r(e, "Key cannot be empty"), { path: `/notifications/${e}`, method: "DELETE" });
var Qr = (e) => () => (r(e, "Keys cannot be empty"), { path: "/operations", body: JSON.stringify(e), method: "DELETE" });
var Tr = (e) => () => (r(e, "Key cannot be empty"), { path: `/operations/${e}`, method: "DELETE" });
var Cr = (e) => () => (r(e, "Keys cannot be empty"), { path: "/panels", body: JSON.stringify(e), method: "DELETE" });
var Rr = (e) => () => (r(e, "Key cannot be empty"), { path: `/panels/${e}`, method: "DELETE" });
var Or = (e) => () => (r(e, "Keys cannot be empty"), { path: "/permissions", body: JSON.stringify(e), method: "DELETE" });
var Pr = (e) => () => (r(String(e), "Key cannot be empty"), { path: `/permissions/${e}`, method: "DELETE" });
var Ar = (e) => () => (r(e, "Keys cannot be empty"), { path: "/presets", body: JSON.stringify(e), method: "DELETE" });
var Er = (e) => () => (r(String(e), "Key cannot be empty"), { path: `/presets/${e}`, method: "DELETE" });
var vr = (e, t) => () => (r(e, "Collection cannot be empty"), r(t, "Field cannot be empty"), { path: `/relations/${e}/${t}`, method: "DELETE" });
var $r = (e) => () => (r(e, "Keys cannot be empty"), { path: "/roles", body: JSON.stringify(e), method: "DELETE" });
var Kr = (e) => () => (r(String(e), "Key cannot be empty"), { path: `/roles/${e}`, method: "DELETE" });
var Wr = (e) => () => (r(e, "Keys cannot be empty"), { path: "/shares", body: JSON.stringify(e), method: "DELETE" });
var kr = (e) => () => (r(String(e), "Key cannot be empty"), { path: `/shares/${e}`, method: "DELETE" });
var _r = (e) => () => (r(e, "Keys cannot be empty"), { path: "/translations", body: JSON.stringify(e), method: "DELETE" });
var Br = (e) => () => (r(String(e), "Key cannot be empty"), { path: `/translations/${e}`, method: "DELETE" });
var zr = (e) => () => (r(e, "Keys cannot be empty"), { path: "/users", body: JSON.stringify(e), method: "DELETE" });
var Xr = (e) => () => (r(String(e), "Key cannot be empty"), { path: `/users/${e}`, method: "DELETE" });
var eo = (e) => () => (r(e, "Keys cannot be empty"), { path: "/versions", body: JSON.stringify(e), method: "DELETE" });
var to = (e) => () => (r(e, "Key cannot be empty"), { path: `/versions/${e}`, method: "DELETE" });
var so = (e) => () => (r(e, "Keys cannot be empty"), { path: "/webhooks", body: JSON.stringify(e), method: "DELETE" });
var mo = (e) => () => (r(String(e), "Key cannot be empty"), { path: `/webhooks/${e}`, method: "DELETE" });
var Fo = (e) => () => ({ path: "/activity", params: e ?? {}, method: "GET" });
var Ao = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/activity/${e}`, params: t ?? {}, method: "GET" });
var No = (e, t) => () => {
  let o = String(e);
  return r(o, "Collection cannot be empty"), { path: o.startsWith("directus_") ? `/${o.substring(9)}` : `/items/${o}`, method: "GET", params: { ...t.query ?? {}, ...t.groupBy ? { groupBy: t.groupBy } : {}, aggregate: t.aggregate } };
};
var Jo = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/assets/${e}`, params: t ?? {}, method: "GET", onResponse: (o) => o.body });
var $o = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/assets/${e}`, params: t ?? {}, method: "GET", onResponse: (o) => o.blob() });
var Ko = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/assets/${e}`, params: t ?? {}, method: "GET", onResponse: (o) => o.arrayBuffer() });
var Wo = () => () => ({ path: "/collections", method: "GET" });
var ko = (e) => () => (r(e, "Collection cannot be empty"), { path: `/collections/${e}`, method: "GET" });
var _o = (e) => () => ({ path: "/dashboards", params: e ?? {}, method: "GET" });
var Bo = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/dashboards/${e}`, params: t ?? {}, method: "GET" });
var Mo = () => () => ({ path: "/extensions/", method: "GET" });
var Yo = () => () => ({ path: "/fields", method: "GET" });
var Zo = (e) => () => (r(e, "Collection cannot be empty"), { path: `/fields/${e}`, method: "GET" });
var es = (e, t) => () => (r(e, "Collection cannot be empty"), r(t, "Field cannot be empty"), { path: `/fields/${e}/${t}`, method: "GET" });
var os = (e) => () => ({ path: "/files", params: e ?? {}, method: "GET" });
var ss = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/files/${e}`, params: t ?? {}, method: "GET" });
var ns = (e) => () => ({ path: "/flows", params: e ?? {}, method: "GET" });
var cs = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/flows/${e}`, params: t ?? {}, method: "GET" });
var ds = (e) => () => ({ path: "/folders", params: e ?? {}, method: "GET" });
var hs = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/folders/${e}`, params: t ?? {}, method: "GET" });
var Ss = (e, t) => () => (r(String(e), "Collection cannot be empty"), h(e, "Cannot use readItems for core collections"), { path: `/items/${e}`, params: t ?? {}, method: "GET" });
var ls = (e, t, o) => () => (r(String(e), "Collection cannot be empty"), h(e, "Cannot use readItem for core collections"), r(String(t), "Key cannot be empty"), { path: `/items/${e}/${t}`, params: o ?? {}, method: "GET" });
var Qs = (e) => () => ({ path: "/notifications", params: e ?? {}, method: "GET" });
var Ts = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/notifications/${e}`, params: t ?? {}, method: "GET" });
var Cs = (e) => () => ({ path: "/operations", params: e ?? {}, method: "GET" });
var Rs = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/operations/${e}`, params: t ?? {}, method: "GET" });
var Os = (e) => () => ({ path: "/panels", params: e ?? {}, method: "GET" });
var Ps = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/panels/${e}`, params: t ?? {}, method: "GET" });
var As = (e) => () => ({ path: "/permissions", params: e ?? {}, method: "GET" });
var Es = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/permissions/${e}`, params: t ?? {}, method: "GET" });
var vs = (e) => () => ({ path: "/presets", params: e ?? {}, method: "GET" });
var Us = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/presets/${e}`, params: t ?? {}, method: "GET" });
var Ks = () => () => ({ path: "/relations", method: "GET" });
var Gs = (e) => () => ({ path: `/relations/${e}`, method: "GET" });
var Ls = (e, t) => () => (r(e, "Collection cannot be empty"), r(t, "Field cannot be empty"), { path: `/relations/${e}/${t}`, method: "GET" });
var Vs = (e) => () => ({ path: "/revisions", params: e ?? {}, method: "GET" });
var Hs = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/revisions/${e}`, params: t ?? {}, method: "GET" });
var qs = (e) => () => ({ path: "/roles", params: e ?? {}, method: "GET" });
var Ms = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/roles/${e}`, params: t ?? {}, method: "GET" });
var Xs = (e) => () => ({ path: "/settings", params: e ?? {}, method: "GET" });
var em = (e) => () => ({ path: "/shares", params: e ?? {}, method: "GET" });
var tm = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/shares/${e}`, params: t ?? {}, method: "GET" });
var sm = (e, t) => () => (r(String(e), "Collection cannot be empty"), h(e, "Cannot use readSingleton for core collections"), { path: `/items/${e}`, params: t ?? {}, method: "GET" });
var nm = (e) => () => ({ path: "/translations", params: e ?? {}, method: "GET" });
var cm = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/translations/${e}`, params: t ?? {}, method: "GET" });
var dm = (e) => () => ({ path: "/users", params: e ?? {}, method: "GET" });
var hm = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/users/${e}`, params: t ?? {}, method: "GET" });
var um = (e) => () => ({ path: "/users/me", params: e ?? {}, method: "GET" });
var lm = (e) => () => ({ path: "/versions", params: e ?? {}, method: "GET" });
var fm = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/versions/${e}`, params: t ?? {}, method: "GET" });
var Tm = (e) => () => ({ path: "/webhooks", params: e ?? {}, method: "GET" });
var bm = (e, t) => () => (r(String(e), "Key cannot be empty"), { path: `/webhooks/${e}`, params: t ?? {}, method: "GET" });
var zm = (e) => () => ({ method: "POST", path: "/schema/apply", body: JSON.stringify(e) });
var Ym = (e, t = false) => () => ({ method: "POST", path: "/schema/diff", params: t ? { force: t } : {}, body: JSON.stringify(e) });
var ea = () => () => ({ method: "GET", path: "/schema/snapshot" });
var aa = (e = "item") => () => ({ method: "GET", path: e === "item" ? "/server/specs/graphql" : "/server/specs/graphql/system" });
var ca = () => () => ({ method: "GET", path: "/server/health" });
var pa = () => () => ({ method: "GET", path: "/server/info" });
var ha = () => () => ({ method: "GET", path: "/server/specs/oas" });
var ya = () => () => ({ method: "GET", path: "/server/ping" });
var Ca = (e, t, o) => () => (r(String(e), "Key cannot be empty"), { path: `/activity/comment/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var ga = (e, t, o) => () => (r(e, "Collection cannot be empty"), { path: `/collections/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var Ia = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/dashboards", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var Fa = (e, t, o) => () => (r(e, "Key cannot be empty"), { path: `/dashboards/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var wa = (e, t, o, s) => () => (r(e, "Keys cannot be empty"), r(t, "Field cannot be empty"), { path: `/fields/${e}/${t}`, params: s ?? {}, body: JSON.stringify(o), method: "PATCH" });
var Ua = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/files", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var Ja = (e, t, o) => () => (r(e, "Key cannot be empty"), t instanceof FormData ? { path: `/files/${e}`, params: o ?? {}, body: t, method: "PATCH", headers: { "Content-Type": "multipart/form-data" } } : { path: `/files/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var Ga = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/flows", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var La = (e, t, o) => () => (r(e, "Key cannot be empty"), { path: `/flows/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var Va = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/folders", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var Ha = (e, t, o) => () => (r(e, "Key cannot be empty"), { path: `/folders/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var qa = (e, t, o, s) => () => (r(t, "Keys cannot be empty"), r(String(e), "Collection cannot be empty"), h(e, "Cannot use updateItems for core collections"), { path: `/items/${e}`, params: s ?? {}, body: JSON.stringify({ keys: t, data: o }), method: "PATCH" });
var Ma = (e, t, o, s) => () => (r(String(t), "Key cannot be empty"), r(String(e), "Collection cannot be empty"), h(e, "Cannot use updateItem for core collections"), { path: `/items/${e}/${t}`, params: s ?? {}, body: JSON.stringify(o), method: "PATCH" });
var Ya = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/notifications", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var Za = (e, t, o) => () => (r(e, "Key cannot be empty"), { path: `/notifications/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var rn = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/operations", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var on = (e, t, o) => () => (r(e, "Key cannot be empty"), { path: `/operations/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var an = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/panels", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var nn = (e, t, o) => () => (r(e, "Key cannot be empty"), { path: `/panels/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var dn = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/permissions", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var hn = (e, t, o) => () => (r(String(e), "Key cannot be empty"), { path: `/permissions/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var Sn = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/presets", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var ln = (e, t, o) => () => (r(String(e), "Key cannot be empty"), { path: `/presets/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var Qn = (e, t, o, s) => () => (r(e, "Collection cannot be empty"), r(t, "Field cannot be empty"), { path: `/relations/${e}/${t}`, params: s ?? {}, body: JSON.stringify(o), method: "PATCH" });
var jn = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/roles", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var Cn = (e, t, o) => () => (r(e, "Key cannot be empty"), { path: `/roles/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var Dn = (e, t) => () => ({ path: "/settings", params: t ?? {}, body: JSON.stringify(e), method: "PATCH" });
var Pn = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/shares", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var In = (e, t, o) => () => (r(e, "Key cannot be empty"), { path: `/shares/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var En = (e, t, o) => () => (r(String(e), "Collection cannot be empty"), h(e, "Cannot use updateSingleton for core collections"), { path: `/items/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var vn = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/translations", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var Un = (e, t, o) => () => (r(String(e), "Key cannot be empty"), { path: `/translations/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var Kn = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/users", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var Gn = (e, t, o) => () => (r(e, "Key cannot be empty"), { path: `/users/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var Ln = (e, t) => () => ({ path: "/users/me", params: t ?? {}, body: JSON.stringify(e), method: "PATCH" });
var Vn = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/versions", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var Hn = (e, t, o) => () => (r(e, "Key cannot be empty"), { path: `/versions/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var qn = (e, t, o) => () => (r(e, "Keys cannot be empty"), { path: "/webhooks", params: o ?? {}, body: JSON.stringify({ keys: e, data: t }), method: "PATCH" });
var Mn = (e, t, o) => () => (r(String(e), "Key cannot be empty"), { path: `/webhooks/${e}`, params: o ?? {}, body: JSON.stringify(t), method: "PATCH" });
var Tc = () => () => ({ method: "POST", path: "/utils/cache/clear" });
var jc = (e, t, o, s) => () => ({ method: "POST", path: `/utils/export/${e}`, body: JSON.stringify({ format: t, query: o, file: s }) });
var Rc = (e, t, o) => () => e === "GET" ? { path: `/flows/trigger/${t}`, params: o ?? {}, method: "GET" } : { path: `/flows/trigger/${t}`, body: JSON.stringify(o ?? {}), method: "POST" };
var gc = (e) => () => ({ method: "POST", path: "/utils/hash/generate", body: JSON.stringify({ string: e }) });
var Oc = (e, t) => () => ({ method: "POST", path: "/utils/hash/verify", body: JSON.stringify({ string: e, hash: t }) });
var Ic = (e, t) => () => ({ path: `/utils/import/${e}`, method: "POST", body: t, headers: { "Content-Type": "multipart/form-data" } });
var Ac = (e, t) => () => ({ path: `/operations/trigger/${e}`, body: JSON.stringify(t ?? {}), method: "POST" });
var wc = (e, t) => () => ({ path: "/shares/auth", method: "POST", body: JSON.stringify({ share: e, password: t }) });
var Nc = (e, t) => () => ({ path: "/shares/invite", method: "POST", body: JSON.stringify({ share: e, emails: t }) });
var vc = (e) => () => ({ path: `/shares/info/${e}`, method: "GET" });
var Jc = (e, t, o) => () => ({ method: "POST", path: `/utils/sort/${e}`, body: JSON.stringify({ item: t, to: o }) });
var Kc = (e, t, o) => () => ({ path: "/users/invite", method: "POST", body: JSON.stringify({ email: e, role: t, ...o ? { invite_url: o } : {} }) });
var Gc = (e, t) => () => ({ path: "/users/invite/accept", method: "POST", body: JSON.stringify({ token: e, password: t }) });
var Lc = (e) => () => ({ path: "/users/me/tfa/generate", method: "POST", body: JSON.stringify({ password: e }) });
var Wc = (e, t) => () => ({ path: "/users/me/tfa/enable", method: "POST", body: JSON.stringify({ secret: e, otp: t }) });
var kc = (e) => () => ({ path: "/users/me/tfa/disable", method: "POST", body: JSON.stringify({ otp: e }) });
var _c = (e, t) => () => (r(e, "ID cannot be empty"), { path: `/versions/${e}/save`, method: "POST", body: JSON.stringify(t) });
var Bc = (e) => () => (r(e, "ID cannot be empty"), { path: `/versions/${e}/compare`, method: "GET" });
var qc = (e, t, o) => () => (r(e, "ID cannot be empty"), { path: `/versions/${e}/promote`, method: "POST", body: JSON.stringify(o ? { mainHash: t, fields: o } : { mainHash: t }) });
var F = {};
var xi = (e = {}) => (t) => {
  let o = { ...F, ...e };
  return { async request(s) {
    let m2 = s();
    if (m2.headers || (m2.headers = {}), "Content-Type" in m2.headers ? m2.headers["Content-Type"] === "multipart/form-data" && delete m2.headers["Content-Type"] : m2.headers["Content-Type"] = "application/json", "getToken" in this) {
      let d = await this.getToken();
      d && (m2.headers || (m2.headers = {}), m2.headers.Authorization = `Bearer ${d}`);
    }
    let c = S(t.url, m2.path, m2.params), a = { method: m2.method ?? "GET", headers: m2.headers ?? {} };
    "credentials" in o && (a.credentials = o.credentials), m2.body && (a.body = m2.body), m2.onRequest && (a = await m2.onRequest(a)), o.onRequest && (a = await o.onRequest(a));
    let n = await y(c.toString(), a, t.globals.fetch);
    return "onResponse" in m2 && (n = await m2.onResponse(n, a)), "onResponse" in e && (n = await e.onResponse(n, a)), n;
  } };
};
function Ti(e, t) {
  return () => {
    let o = e();
    return typeof t == "function" ? o.onRequest = t : o.onRequest = (s) => ({ ...s, ...t }), o;
  };
}
function ji(e) {
  return () => {
    let t = e();
    return t.method === "GET" && (t.method = "SEARCH", t.body = JSON.stringify({ query: t.params }), delete t.params), t;
  };
}
function Ri(e, t) {
  return () => {
    let o = t();
    return e && (o.headers || (o.headers = {}), o.headers.Authorization = `Bearer ${e}`), o;
  };
}
var b = "/";
var A = (e, t) => (e.endsWith(b) && (e = e.slice(0, -1)), t.startsWith(b) || (t = b + t), e + t);
var S = (e, t, o) => {
  let s = e.pathname === b ? t : A(e.pathname, t), m2 = new globalThis.URL(s, e);
  if (o)
    for (let [c, a] of Object.entries(O(o)))
      if (a && typeof a == "object" && !Array.isArray(a))
        for (let [n, d] of Object.entries(a))
          m2.searchParams.set(`${c}[${n}]`, String(d));
      else
        m2.searchParams.set(c, a);
  return m2;
};
var P = () => {
  let e = null;
  return { get: async () => e, set: async (t) => {
    e = t;
  } };
};
var E = { msRefreshBeforeExpires: 3e4, autoRefresh: true };
var fp = (e = "cookie", t = {}) => (o) => {
  let s = { ...E, ...t }, m2 = null, c = null, a = s.storage ?? P(), n = () => {
    a.set({ access_token: null, refresh_token: null, expires: null, expires_at: null });
  }, d = async () => {
    try {
      await m2;
    } finally {
      m2 = null;
    }
  }, f = async () => {
    let p = await a.get();
    if (m2 || !(p == null ? void 0 : p.expires_at)) {
      await d();
      return;
    }
    p.expires_at < (/* @__PURE__ */ new Date()).getTime() + s.msRefreshBeforeExpires && j().catch((i) => {
    }), await d();
  }, l = (p) => {
    let i = p.expires ?? 0;
    p.expires_at = (/* @__PURE__ */ new Date()).getTime() + i, a.set(p), s.autoRefresh && i > s.msRefreshBeforeExpires && i < Number.MAX_SAFE_INTEGER && (c && clearTimeout(c), c = setTimeout(() => {
      c = null, j().catch((u) => {
      });
    }, i - s.msRefreshBeforeExpires));
  }, j = async () => (m2 = (async () => {
    let i = await a.get();
    n();
    let u = { method: "POST", headers: { "Content-Type": "application/json" } };
    "credentials" in s && (u.credentials = s.credentials);
    let T = { mode: e };
    e === "json" && (i == null ? void 0 : i.refresh_token) && (T.refresh_token = i.refresh_token), u.body = JSON.stringify(T);
    let x = S(o.url, "/auth/refresh"), Q = await y(x.toString(), u, o.globals.fetch);
    return l(Q), Q;
  })().catch((i) => {
    throw i;
  }), m2);
  return { refresh: j, async login(p, i, u = {}) {
    n();
    let T = S(o.url, "/auth/login"), x = { email: p, password: i };
    "otp" in u && (x.otp = u.otp), x.mode = u.mode ?? e;
    let Q = { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(x) };
    "credentials" in s && (Q.credentials = s.credentials);
    let C = await y(T.toString(), Q, o.globals.fetch);
    return l(C), C;
  }, async logout() {
    let p = await a.get(), i = { method: "POST", headers: { "Content-Type": "application/json" } };
    "credentials" in s && (i.credentials = s.credentials), e === "json" && (p == null ? void 0 : p.refresh_token) && (i.body = JSON.stringify({ refresh_token: p.refresh_token }));
    let u = S(o.url, "/auth/logout");
    await y(u.toString(), i, o.globals.fetch), c && clearTimeout(c), n();
  }, async getToken() {
    var _a;
    return await f(), ((_a = await a.get()) == null ? void 0 : _a.access_token) ?? null;
  }, setToken(p) {
    a.set({ access_token: p, refresh_token: null, expires: null, expires_at: null });
  } };
};
var Qp = (e) => (t) => {
  let o = e ?? null;
  return { async getToken() {
    return o;
  }, setToken(s) {
    o = s;
  } };
};

// node_modules/@directus/sdk/dist/chunk-35FIPLD2.js
function g2(t) {
  return JSON.stringify({ ...t, type: "auth" });
}
var W2 = () => JSON.stringify({ type: "pong" });
var k = (t, u = 1e3) => new Promise((o, b2) => {
  let h2 = (E2) => {
    try {
      let p = JSON.parse(E2.data);
      typeof p == "object" && !Array.isArray(p) && p !== null ? (l(), o(p)) : (l(), c());
    } catch {
      l(), o(E2);
    }
  }, c = () => b2(), l = () => {
    clearTimeout(y2), t.removeEventListener("message", h2), t.removeEventListener("error", c), t.removeEventListener("close", c);
  };
  t.addEventListener("message", h2), t.addEventListener("error", c), t.addEventListener("close", c);
  let y2 = setTimeout(() => {
    l(), o(void 0);
  }, u);
});
function* w2() {
  let t = 1;
  for (; ; )
    yield String(t), t++;
}
var O2 = { authMode: "handshake", heartbeat: true, reconnect: { delay: 1e3, retries: 10 } };
var m = { OPEN: 1, CLOSED: 3 };
function _2(t = {}) {
  return (u) => {
    t = { ...O2, ...t };
    let o = null, b2 = w2(), h2 = 0, c = false, l = (e) => "getToken" in e, y2 = async (e, n) => {
      if (t.authMode === "strict" && l(n)) {
        let r2 = await n.getToken();
        r2 && e.searchParams.set("access_token", r2);
      }
      return e;
    }, E2 = async (e) => {
      if ("url" in t)
        return await y2(new u.globals.URL(t.url), e);
      if (["ws:", "wss:"].includes(u.url.protocol))
        return await y2(u.url, e);
      let n = new u.globals.URL(u.url.toString());
      return n.protocol = u.url.protocol === "https:" ? "wss:" : "ws:", n.pathname = "/websocket", await y2(n, e);
    }, p = () => {
      o = null, b2 = w2();
    };
    function x() {
      t.reconnect && !c && h2 < t.reconnect.retries ? (c = true, setTimeout(() => {
        h2 += 1, this.connect().then(() => {
          h2 = 0, c = false;
        }).catch(() => {
        });
      }, Math.max(1, t.reconnect.delay))) : c = false;
    }
    let d = { open: /* @__PURE__ */ new Set([]), error: /* @__PURE__ */ new Set([]), close: /* @__PURE__ */ new Set([]), message: /* @__PURE__ */ new Set([]) }, C = async (e, n) => {
      for (; e.readyState !== m.CLOSED; ) {
        let r2 = await k(e).catch(() => {
        });
        if (r2) {
          if ("type" in r2) {
            if (r2.type === "auth" && "status" in r2 && r2.status === "error" && "error" in r2) {
              if (r2.error === "TOKEN_EXPIRED" && l(n)) {
                let i = await n.getToken();
                if (i) {
                  e.send(g2({ access_token: i }));
                  continue;
                }
              }
              if (r2.error === "AUTH_TIMEOUT") {
                e.close();
                continue;
              }
            }
            if (t.heartbeat && r2.type === "ping") {
              e.send(W2());
              continue;
            }
          }
          d.message.forEach((i) => i.call(e, r2));
        }
      }
    };
    return { async connect() {
      let e = this, n = await E2(e);
      return new Promise((r2, i) => {
        let S2 = false, a = new u.globals.WebSocket(n);
        a.addEventListener("open", async (s) => {
          if (t.authMode === "handshake" && l(e)) {
            let f = await e.getToken();
            f && a.send(g2({ access_token: f }));
          }
          S2 = true, d.open.forEach((f) => f.call(a, s)), C(a, e), r2();
        }), a.addEventListener("error", (s) => {
          d.error.forEach((f) => f.call(a, s)), a.close(), S2 || i(s);
        }), a.addEventListener("close", (s) => {
          d.close.forEach((f) => f.call(a, s)), p(), x.call(this), S2 || i(s);
        }), o = a;
      });
    }, disconnect() {
      o && (o == null ? void 0 : o.readyState) === m.OPEN && o.close(), o = null;
    }, onWebSocket(e, n) {
      if (e === "message") {
        let r2 = function(i) {
          if (typeof i.data != "string")
            return n.call(this, i);
          try {
            return n.call(this, JSON.parse(i.data));
          } catch {
            return n.call(this, i);
          }
        };
        return d[e].add(r2), () => d[e].delete(r2);
      }
      return d[e].add(n), () => d[e].delete(n);
    }, sendMessage(e) {
      if (!o || (o == null ? void 0 : o.readyState) !== m.OPEN)
        throw new Error("websocket connection not OPEN");
      if (typeof e == "string") {
        o.send(e);
        return;
      }
      "uid" in e || (e.uid = b2.next().value), o == null ? void 0 : o.send(JSON.stringify(e));
    }, async subscribe(e, n = {}) {
      (!o || o.readyState !== m.OPEN) && await this.connect(), "uid" in n || (n.uid = b2.next().value);
      let r2 = true, i = o, S2 = (s) => i.send(JSON.stringify(s));
      S2({ ...n, collection: e, type: "subscribe" });
      async function* a() {
        for (; r2 && i && i.readyState === m.OPEN; ) {
          let s = await k(i).catch(() => {
          });
          if (s) {
            if ("type" in s && "status" in s && s.type === "subscribe" && s.status === "error")
              throw s;
            "type" in s && "uid" in s && s.type === "subscription" && s.uid === n.uid && (yield s);
          }
        }
        if (t.reconnect && c) {
          for (; c; )
            await v(10);
          o && o.readyState === m.OPEN && (o.send(JSON.stringify({ ...n, collection: e, type: "subscribe" })), yield* a());
        }
      }
      return { subscription: a(), unsubscribe() {
        S2({ uid: n.uid, type: "unsubscribe" }), r2 = false;
      } };
    } };
  };
}
var v = (t) => new Promise((u) => setTimeout(() => u(), t));
export {
  Gc as acceptUserInvite,
  No as aggregate,
  g2 as auth,
  wc as authenticateShare,
  fp as authentication,
  Tc as clearCache,
  Bc as compareContentVersion,
  ue as createCollection,
  de as createComment,
  ct as createContentVersion,
  nt as createContentVersions,
  le as createDashboard,
  Se as createDashboards,
  w as createDirectus,
  xe as createField,
  Re as createFlow,
  Ce as createFlows,
  Oe as createFolder,
  ge as createFolders,
  Fe as createItem,
  Ie as createItems,
  we as createNotification,
  Ee as createNotifications,
  Ue as createOperation,
  ve as createOperations,
  Ke as createPanel,
  $e as createPanels,
  We as createPermission,
  Le as createPermissions,
  He as createPreset,
  Ve as createPresets,
  Be as createRelation,
  ze as createRole,
  Me as createRoles,
  Ze as createShare,
  Ye as createShares,
  rt as createTranslation,
  tt as createTranslations,
  mt as createUser,
  st as createUsers,
  dt as createWebhook,
  pt as createWebhooks,
  Ut as deleteCollection,
  Nt as deleteComment,
  to as deleteContentVersion,
  eo as deleteContentVersions,
  Bt as deleteDashboard,
  _t as deleteDashboards,
  zt as deleteField,
  er as deleteFile,
  Zt as deleteFiles,
  sr as deleteFlow,
  or as deleteFlows,
  cr as deleteFolder,
  nr as deleteFolders,
  hr as deleteItem,
  dr as deleteItems,
  lr as deleteNotification,
  Sr as deleteNotifications,
  Tr as deleteOperation,
  Qr as deleteOperations,
  Rr as deletePanel,
  Cr as deletePanels,
  Pr as deletePermission,
  Or as deletePermissions,
  Er as deletePreset,
  Ar as deletePresets,
  vr as deleteRelation,
  Kr as deleteRole,
  $r as deleteRoles,
  kr as deleteShare,
  Wr as deleteShares,
  Br as deleteTranslation,
  _r as deleteTranslations,
  Xr as deleteUser,
  zr as deleteUsers,
  mo as deleteWebhook,
  so as deleteWebhooks,
  kc as disableTwoFactor,
  Wc as enableTwoFactor,
  gc as generateHash,
  Lc as generateTwoFactorSecret,
  w2 as generateUid,
  W as graphql,
  be as importFile,
  Nc as inviteShare,
  Kc as inviteUser,
  _ as login,
  q as logout,
  P as memoryStorage,
  k as messageCallback,
  z as passwordRequest,
  Y as passwordReset,
  W2 as pong,
  qc as promoteContentVersion,
  O as queryToParams,
  Fo as readActivities,
  Ao as readActivity,
  Ko as readAssetArrayBuffer,
  $o as readAssetBlob,
  Jo as readAssetRaw,
  ko as readCollection,
  Wo as readCollections,
  fm as readContentVersion,
  lm as readContentVersions,
  Bo as readDashboard,
  _o as readDashboards,
  Mo as readExtensions,
  es as readField,
  Yo as readFields,
  Zo as readFieldsByCollection,
  ss as readFile,
  os as readFiles,
  cs as readFlow,
  ns as readFlows,
  hs as readFolder,
  ds as readFolders,
  aa as readGraphqlSdl,
  ls as readItem,
  Ss as readItems,
  um as readMe,
  Ts as readNotification,
  Qs as readNotifications,
  ha as readOpenApiSpec,
  Rs as readOperation,
  Cs as readOperations,
  Ps as readPanel,
  Os as readPanels,
  Es as readPermission,
  As as readPermissions,
  Us as readPreset,
  vs as readPresets,
  ee as readProviders,
  Ls as readRelation,
  Gs as readRelationByCollection,
  Ks as readRelations,
  Hs as readRevision,
  Vs as readRevisions,
  Ms as readRole,
  qs as readRoles,
  Xs as readSettings,
  tm as readShare,
  vc as readShareInfo,
  em as readShares,
  sm as readSingleton,
  cm as readTranslation,
  nm as readTranslations,
  hm as readUser,
  dm as readUsers,
  bm as readWebhook,
  Tm as readWebhooks,
  _2 as realtime,
  re as refresh,
  xi as rest,
  _c as saveToContentVersion,
  zm as schemaApply,
  Ym as schemaDiff,
  ea as schemaSnapshot,
  ca as serverHealth,
  pa as serverInfo,
  ya as serverPing,
  v as sleep,
  Qp as staticToken,
  h as throwIfCoreCollection,
  r as throwIfEmpty,
  Rc as triggerFlow,
  Ac as triggerOperation,
  ga as updateCollection,
  Ca as updateComment,
  Hn as updateContentVersion,
  Vn as updateContentVersions,
  Fa as updateDashboard,
  Ia as updateDashboards,
  wa as updateField,
  Ja as updateFile,
  Ua as updateFiles,
  La as updateFlow,
  Ga as updateFlows,
  Ha as updateFolder,
  Va as updateFolders,
  Ma as updateItem,
  qa as updateItems,
  Ln as updateMe,
  Za as updateNotification,
  Ya as updateNotifications,
  on as updateOperation,
  rn as updateOperations,
  nn as updatePanel,
  an as updatePanels,
  hn as updatePermission,
  dn as updatePermissions,
  ln as updatePreset,
  Sn as updatePresets,
  Qn as updateRelation,
  Cn as updateRole,
  jn as updateRoles,
  Dn as updateSettings,
  In as updateShare,
  Pn as updateShares,
  En as updateSingleton,
  Un as updateTranslation,
  vn as updateTranslations,
  Gn as updateUser,
  Kn as updateUsers,
  Mn as updateWebhook,
  qn as updateWebhooks,
  Te as uploadFiles,
  Jc as utilitySort,
  jc as utilsExport,
  Ic as utilsImport,
  Oc as verifyHash,
  Ti as withOptions,
  ji as withSearch,
  Ri as withToken
};
//# sourceMappingURL=@directus_sdk.js.map
